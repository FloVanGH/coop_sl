// SPDX-FileCopyrightText: 2022 Florian Blasius <co-sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { Duration, Icography, Radius, Palette, Size, State, Space, Icons } from "../styling.slint";
import { ScrollView } from "scroll-view.slint";
import { CheckableBase } from "checkables.slint";
import { LargeLabel, FocusBorder } from "../components.slint";
import { LineEdit } from "line-edit.slint";

export enum SelectionMode {
    None,
    Single,
    Custom
}

export struct ListViewItem  {
    leading-icon: image,
    text: string,
    trailing-icon: image,
    highlighted: bool,
    spec: string,

    // this is only used for custom selection
    selected: bool
}

export struct GroupListViewItem  {
    text: string,
    items: [ListViewItem],
}

export component ItemDelegate inherits TouchArea {
    private property <brush> foreground: Palette.foreground;
    private property <brush> icon-color: highlighted ? Palette.primary : Palette.foreground;
    private property <brush> text-color: root.foreground;

    callback accepted(/* text*/ string);

    in property <bool> selected;
    in property <bool> highlighted;
    in property <image> leading-icon;
    in property <image> trailing-icon;
    in property <bool> edit;
    in-out property <string> text;

    min-height: max(Size.small, i-layout.min-height);
    padding-right: Space.medium;
    padding-left: Space.medium;

    i-background := Rectangle {
       i-layout := HorizontalLayout {
            padding-left: root.padding-left;
            padding-right: root.padding-right;
            spacing: Space.medium;

            if (root.leading-icon.width > 0 && root.leading-icon.height > 0) : Image {
                source: root.leading-icon;
                colorize: root.icon-color;
                width: Icography.small;
            }

            if (!root.edit) : LargeLabel {
                text <=> root.text;
                vertical-alignment: center;
                horizontal-alignment: left;
                color: root.foreground;
                overflow: elide;
            }

            if (root.edit) : LineEdit {
                y: (parent.height - self.height) / 2;
                text: root.text;
                height: Size.extra-small;

                accepted(text) => {
                    root.accepted(text);
                }
            }

            if (root.trailing-icon.width > 0 && root.trailing-icon.height > 0) : Image {
                source: root.trailing-icon;
                colorize: root.foreground;
                width: Icography.small;
            }
        }
    }

    states [
        disabled when !root.enabled: {
            root.text-color: Palette.foreground-disabled;
            root.icon-color: Palette.foreground-disabled;
        }

        pressed when root.pressed: {
            i-background.background: Palette.background.darker(State.pressed);
            foreground: Palette.foreground.darker(State.pressed);
            icon-color: highlighted ? Palette.primary.darker(State.pressed) : Palette.foreground.darker(State.pressed);
        }
        hover when root.has-hover: {
            i-background.background: Palette.background.darker(State.hover);
            foreground: Palette.foreground.darker(State.hover);
            icon-color: highlighted ? Palette.primary.darker(State.hover) : Palette.foreground.darker(State.hover);
        }
        selected when root.selected: {
            i-background.background: Palette.background.darker(State.selected);
        }
    ]

    animate foreground { duration: Duration.fast; }
}

// Delegate for a `GroupListViewItem` it can display a `text` and a list of `ItemModels`.
component GroupItemDelegate {
    private property <brush> foreground: Palette.foreground;

    callback current-item-changed(/* current-item */ { parent: int, item: int });
    callback item-pointer-event(/* item-index */ int, /* event */ PointerEvent, /* absolute mouse position */ Point);

    in property <GroupListViewItem> model;
    in property <int> item-index;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in-out property <{ parent: int, item: int }> current-item: { parent: -1, item: -1};
    in-out property <bool> expanded: true;

    min-height: max(Size.small, i-layout.min-height);
    forward-focus: i-focus-scope;

    i-layout := VerticalLayout {
        spacing: root.expanded ? Space.medium : 0;

        i-background := Rectangle {
            height: Size.small;

            i-background-layout := HorizontalLayout {
                padding-left: Space.medium;
                padding-right: Space.medium;
                spacing: Space.medium;

                Image {
                    y: (parent.height - self.height) / 2;
                    source: Icons.arrow-drop-down;
                    colorize: root.foreground;

                    states [
                        collapsed when !root.expanded: {
                            source: Icons.arrow-right;
                        }
                    ]
                }

                LargeLabel  {
                    color: root.foreground;
                    text: root.model.text;
                    vertical-alignment: center;
                    horizontal-alignment: left;
                    horizontal-stretch: 1;
                }
            }

            // The item is expandable if it has items.
            i-touch-area := TouchArea {
                clicked => {
                    root.expanded = !root.expanded;
                }
            }

            i-focus-scope := FocusScope {
                x:0;
                width: 0px; // Do not react on clicks

                key-pressed(event) => {
                    if(event.text == " " || event.text == "\n") {
                        i-touch-area.clicked();
                        return accept;
                    }
                    return reject;
                }
            }

            if (i-focus-scope.has-focus) : FocusBorder {}

            animate background { duration: Duration.fast; }
        }

        VerticalLayout {
            for item[item-index] in root.model.items: ItemDelegate {
                padding-left: i-background-layout.padding-left + i-background-layout.spacing + Icography.medium;
                padding-right: i-background-layout.padding-right;
                leading-icon: item.leading-icon;
                highlighted: item.highlighted;
                text: item.text;
                trailing-icon: item.trailing-icon;
                selected: (root.item-index == root.current-item.parent && item-index == root.current-item.item
                    && root.selection-mode == SelectionMode.Single)
                    || (root.selection-mode == SelectionMode.Custom && item.selected);
                height: self.min-height;

                clicked => {
                    if(root.selection-mode == SelectionMode.None) {
                        return;
                    }
                    root.current-item = { parent: root.item-index, item: item-index };
                    root.current-item-changed(root.current-item);
                }

                pointer-event(pe) => {
                    root.item-pointer-event(item-index, pe, {
                        x: self.absolute-position.x + self.mouse-x - root.absolute-position.x,
                        y: self.absolute-position.y + self.mouse-y - root.absolute-position.y,
                    });
                }

                states [
                    collapsed when !root.expanded : {
                        height: 0;
                        opacity: 0;
                    }
                ]

                animate height { duration: Duration.fast; easing: cubic-bezier(0.05, 0.7, 0.1, 1.0); }
            }
        }
    }

    states [
        pressed when i-touch-area.pressed: {
            i-background.background: Palette.background.darker(State.pressed);
            foreground: Palette.foreground.darker(State.pressed);
        }
        hover when i-touch-area.has-hover: {
            i-background.background: Palette.background.darker(State.hover);
            foreground: Palette.foreground.darker(State.hover);
        }
    ]

    animate foreground { duration: Duration.fast; }
}

export component ListView inherits ScrollView {
    @children
}

component StandardListViewBase inherits ListView {
    private property <int> into-view-item;
    private property <length> item-height: self.viewport-height / self.model.length;
    private property <length> into-view-item-y: self.viewport-y + current-item * item-height;

    callback current-item-changed(/* current-item */ int);
    callback item-pointer-event(/* item-index */ int, /* event */ PointerEvent, /* absolute mouse position */ Point);
    callback item-accepted(/* row */ int, /* text */ string);

    in property <[ListViewItem]> model;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in property <int> edit-item: -1;
    in-out property <int> current-item: -1;

    for item[index] in root.model : ItemDelegate {
        height: self.min-height;
        selected: (index == root.current-item && root.selection-mode == SelectionMode.Single)
            || (item.selected && root.selection-mode == SelectionMode.Custom);
        edit: index == root.edit-item;
        leading-icon: item.leading-icon;
        text: item.text;
        trailing-icon: item.trailing-icon;
        highlighted: item.highlighted;

        clicked => {
            set-current-item(index);
        }

        pointer-event(pe) => {
            root.item-pointer-event(index, pe, {
                x: self.absolute-position.x + self.mouse-x - root.absolute-position.x,
                y: self.absolute-position.y + self.mouse-y - root.absolute-position.y,
            });
        }

        accepted(text) => {
            root.item-accepted(index, text);
        }
    }

    public function set-current-item(index: int) {
        if (index < 0 || index >= model.length || root.selection-mode == SelectionMode.None || root.selection-mode == SelectionMode.Custom) {
            return;
        }

        current-item = index;
        root.current-item-changed(current-item);
        bring-into-view(current-item);
    }

    public function bring-into-view(row: int) {
        into-view-item = row;

        if (into-view-item-y < 0) {
            self.viewport-y += 0 - into-view-item-y;
        }

        if (into-view-item-y + item-height > self.visible-height) {
            self.viewport-y -= into-view-item-y + item-height - self.visible-height;
        }
    }
}

export component StandardListView inherits StandardListViewBase {
    FocusScope {
        x: 0;
        width: 0;  // Do not react on clicks

        key-pressed(event) => {
            if (event.text == Key.UpArrow) {
                root.set-current-item(root.current-item - 1);
                return accept;
            } else if (event.text == Key.DownArrow) {
                root.set-current-item(root.current-item + 1);
                return accept;
            }

            reject
        }
    }
}

export component GroupListView inherits ScrollView  {
    callback current-item-changed(/* current-item */ { parent: int, item: int });
    callback item-pointer-event(int /* parent-index */, int /* item-index */, PointerEvent /* event */, Point /* absolute mouse position */);

    in property <[GroupListViewItem]> model;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in-out property <{ parent: int, item: int }> current-item;

    VerticalLayout {
        spacing: Space.medium;

        for parent-item[parent-index] in root.model: VerticalLayout {
           GroupItemDelegate {
                model: parent-item;
                item-index: parent-index;
                current-item <=> root.current-item;
                height: self.min-height;
                selection-mode: root.selection-mode;

                current-item-changed(item) => {
                    root.current-item-changed(item);
                }

                item-pointer-event(index, event, position) => {
                    root.item-pointer-event(parent-index, index, event, {
                        x: position.x,
                        y: position.y,
                    });
                }
            }
        }
    }
}