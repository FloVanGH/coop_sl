// SPDX-FileCopyrightText: 2022 Florian Blasius <co-sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { Duration, Icography, Radius, Palette, Size, State, Space, Icons } from "../styling.slint";
import { ScrollView } from "scroll-view.slint";
import { CheckableBase } from "checkables.slint";
import { LargeLabel, FocusBorder } from "../components.slint";
import { LineEdit } from "line-edit.slint";

export enum SelectionMode {
    None,
    Single,
    Custom
}

export struct ListViewItem  {
    leading-icon: image,
    text: string,
    trailing-icon: image,
    highlighted: bool,
    spec: string,

    // this is only used for custom selection
    selected: bool
}

export struct GroupListViewItem  {
    text: string,
    items: [ListViewItem],
}

export component ItemDelegate inherits TouchArea {
    private property <brush> foreground: Palette.foreground;
    private property <brush> icon-color: highlighted ? Palette.primary : Palette.foreground;
    private property <brush> text-color: root.foreground;

    callback accepted(/* text*/ string);

    in property <bool> selected;
    in property <bool> highlighted;
    in property <image> leading-icon;
    in property <image> trailing-icon;
    in property <bool> edit;
    in property <bool> has-focus;
    in-out property <string> text;

    min-height: max(Size.small, i-layout.min-height);
    padding-right: Space.medium;
    padding-left: Space.medium;

    i-background := Rectangle {
       i-layout := HorizontalLayout {
            padding-left: root.padding-left;
            padding-right: root.padding-right;
            spacing: Space.medium;

            if (root.leading-icon.width > 0 && root.leading-icon.height > 0) : Image {
                source: root.leading-icon;
                colorize: root.icon-color;
                width: Icography.small;
            }

            if (!root.edit) : LargeLabel {
                text <=> root.text;
                vertical-alignment: center;
                horizontal-alignment: left;
                color: root.foreground;
                overflow: elide;
            }

            if (root.edit) : LineEdit {
                y: (parent.height - self.height) / 2;
                text: root.text;
                height: Size.extra-small;

                accepted(text) => {
                    root.accepted(text);
                }
            }

            if (root.trailing-icon.width > 0 && root.trailing-icon.height > 0) : Image {
                source: root.trailing-icon;
                colorize: root.foreground;
                width: Icography.small;
            }
        }
    }

    if (root.selected && root.has-focus) : FocusBorder {
        width: 100%;
        height: 100%;
    }

    states [
        disabled when !root.enabled: {
            root.text-color: Palette.foreground-disabled;
            root.icon-color: Palette.foreground-disabled;
        }

        pressed when root.pressed: {
            i-background.background: Palette.background.darker(State.pressed);
            foreground: Palette.foreground.darker(State.pressed);
            icon-color: highlighted ? Palette.primary.darker(State.pressed) : Palette.foreground.darker(State.pressed);
        }
        hover when root.has-hover: {
            i-background.background: Palette.background.darker(State.hover);
            foreground: Palette.foreground.darker(State.hover);
            icon-color: highlighted ? Palette.primary.darker(State.hover) : Palette.foreground.darker(State.hover);
        }
        selected when root.selected: {
            i-background.background: Palette.background.darker(State.selected);
        }
    ]

    animate foreground { duration: Duration.fast; }
}

// Delegate for a `GroupListViewItem` it can display a `text` and a list of `ItemModels`.
component GroupItemDelegate {
    private property <brush> foreground: Palette.foreground;

    callback item-clicked(/* row */ int);
    callback item-pointer-event(/* row */ int, /* event */ PointerEvent, /* absolute mouse position */ Point);

    in property <GroupListViewItem> model;
    in property <int> item-row;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in-out property <{ parent: int, item: int }> current-item: { parent: -1, item: -1};
    in-out property <bool> expanded: true;
    in property <bool> has-focus;

    min-height: max(Size.small, i-layout.min-height);

    i-layout := VerticalLayout {
        spacing: root.expanded ? Space.medium : 0;

        i-background := Rectangle {
            height: Size.small;

            i-background-layout := HorizontalLayout {
                padding-left: Space.medium;
                padding-right: Space.medium;
                spacing: Space.medium;

                Image {
                    y: (parent.height - self.height) / 2;
                    source: Icons.arrow-drop-down;
                    colorize: root.foreground;

                    states [
                        collapsed when !root.expanded: {
                            source: Icons.arrow-right;
                        }
                    ]
                }

                LargeLabel  {
                    color: root.foreground;
                    text: root.model.text;
                    vertical-alignment: center;
                    horizontal-alignment: left;
                    horizontal-stretch: 1;
                }
            }

            // The item is expandable if it has items.
            i-touch-area := TouchArea {
                clicked => {
                    root.expanded = !root.expanded;
                }
            }

            animate background { duration: Duration.fast; }
        }

        VerticalLayout {
            for item[item-row] in root.model.items: ItemDelegate {
                padding-left: i-background-layout.padding-left + i-background-layout.spacing + Icography.medium;
                padding-right: i-background-layout.padding-right;
                leading-icon: item.leading-icon;
                highlighted: item.highlighted;
                text: item.text;
                trailing-icon: item.trailing-icon;
                selected: (root.item-row == root.current-item.parent && item-row == root.current-item.item
                    && root.selection-mode == SelectionMode.Single)
                    || (root.selection-mode == SelectionMode.Custom && item.selected);
                height: self.min-height;
                has-focus: root.has-focus;

                clicked => {
                    if(root.selection-mode == SelectionMode.None) {
                        return;
                    }
                    root.current-item = { parent: root.item-row, item: item-row };
                    root.item-clicked(item-row);
                }

                pointer-event(pe) => {
                    root.item-pointer-event(item-row, pe, {
                        x: self.absolute-position.x + self.mouse-x - root.absolute-position.x,
                        y: self.absolute-position.y + self.mouse-y - root.absolute-position.y,
                    });
                }

                states [
                    collapsed when !root.expanded : {
                        height: 0;
                        opacity: 0;
                    }
                ]

                animate height { duration: Duration.fast; easing: cubic-bezier(0.05, 0.7, 0.1, 1.0); }
            }
        }
    }

    states [
        pressed when i-touch-area.pressed: {
            i-background.background: Palette.background.darker(State.pressed);
            foreground: Palette.foreground.darker(State.pressed);
        }
        hover when i-touch-area.has-hover: {
            i-background.background: Palette.background.darker(State.hover);
            foreground: Palette.foreground.darker(State.hover);
        }
    ]

    animate foreground { duration: Duration.fast; }
}

export component ListView inherits ScrollView {
    @children
}

export component StandardListView  {
    private property <int> into-view-item;
    private property <length> item-height: i-list-view.viewport-height / self.model.length;
    private property <length> into-view-item-y: i-list-view.viewport-y + into-view-item * item-height;

    callback current-item-changed(/* current-item */ int);
    callback item-pointer-event(/* item-row */ int, /* event */ PointerEvent, /* absolute mouse position */ Point);
    callback item-accepted(/* row */ int, /* text */ string);
    callback key-pressed(/* event */ KeyEvent) -> EventResult;

    in property <[ListViewItem]> model;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in property <int> edit-item: -1;
    in property <bool> enabled <=> i-list-view.enabled;
    out property <bool> has-focus: i-focus-scope.has-focus;
    in-out property <int> current-item: -1;

    forward-focus: i-focus-scope;
    min-width: Size.medium;
    min-height: root.min-width;
    horizontal-stretch: 1;
    vertical-stretch: 1;
    preferred-height: 100%;
    preferred-width: 100%;

    i-focus-scope := FocusScope {
        x: 0;
        width: 0;  // Do not react on clicks
        enabled: root.enabled;

        key-pressed(event) => {
            if (root.key-pressed(event) == accept) {
                return accept;
            }

            if (root.selection-mode != SelectionMode.Custom) {
                if (event.text == Key.UpArrow) {
                    root.set-current-item(root.current-item - 1);
                    return accept;
                } else if (event.text == Key.DownArrow) {
                    root.set-current-item(root.current-item + 1);
                    return accept;
                }
            }

            reject
        }
    }

    Rectangle {
        i-list-view := ListView {
            for item[index] in root.model : ItemDelegate {
                has-focus: root.has-focus;
                height: self.min-height;
                selected: (index == root.current-item && root.selection-mode == SelectionMode.Single)
                    || (item.selected && root.selection-mode == SelectionMode.Custom);
                edit: index == root.edit-item;
                leading-icon: item.leading-icon;
                text: item.text;
                trailing-icon: item.trailing-icon;
                highlighted: item.highlighted;

                clicked => {
                    set-current-item(index);
                }

                pointer-event(pe) => {
                    root.item-pointer-event(index, pe, {
                        x: self.absolute-position.x + self.mouse-x - root.absolute-position.x,
                        y: self.absolute-position.y + self.mouse-y - root.absolute-position.y,
                    });
                }

                accepted(text) => {
                    root.item-accepted(index, text);
                }
            }
        }

        @children
    }

    public function set-current-item(index: int) {
        if (index < 0 || index >= model.length || root.selection-mode == SelectionMode.None || root.selection-mode == SelectionMode.Custom) {
            return;
        }

        current-item = index;
        root.current-item-changed(current-item);
        bring-into-view(current-item);
    }

    public function bring-into-view(row: int) {
        into-view-item = row;

        if (into-view-item-y < 0) {
            i-list-view.viewport-y += 0 - into-view-item-y;
        }

        if (into-view-item-y + item-height > i-list-view.visible-height) {
            i-list-view.viewport-y -= into-view-item-y + item-height - i-list-view.visible-height;
        }
    }

    public function item-y(row: int) -> length {
        i-list-view.viewport-y + row * item-height + item-height / 2
    }
}

export component GroupListView  {
    callback current-item-changed(/* current-item */ { parent: int, item: int });
    callback item-pointer-event(int /* par-row */, int /* item-row */, PointerEvent /* event */, Point /* absolute mouse position */);
    callback key-pressed(/* event */ KeyEvent) -> EventResult;

    in property <[GroupListViewItem]> model;
    in property <SelectionMode> selection-mode: SelectionMode.Single;
    in property <bool> enabled: i-list-view.enabled;
    out property <bool> has-focus: i-focus-scope.has-focus;
    in-out property <{ parent: int, item: int }> current-item;

    forward-focus: i-focus-scope;
    min-width: Size.medium;
    min-height: root.min-width;
    horizontal-stretch: 1;
    vertical-stretch: 1;
    preferred-height: 100%;
    preferred-width: 100%;

    i-focus-scope := FocusScope {
        width: 0px;
        height: 0px;
        enabled: root.enabled;

        key-pressed(event) => {
            if (root.key-pressed(event) == accept) {
                return accept;
            }

            if (root.selection-mode != SelectionMode.Custom) {
                if (event.text == Key.UpArrow) {
                    if (root.current-item.item == 0) {
                        root.set-current-item(root.model[root.current-item.parent - 1].items.length - 1, root.current-item.parent - 1);
                    } else {
                        root.set-current-item(root.current-item.item - 1, root.current-item.parent);
                    }

                    return accept;
                }

                if (event.text == Key.DownArrow) {
                    if (root.current-item.item == root.model[root.current-item.parent].items.length - 1) {
                        root.set-current-item(0, root.current-item.parent + 1);
                    } else {
                        root.set-current-item(root.current-item.item + 1, root.current-item.parent);
                    }

                    return accept;
                }
            }

            reject
        }
    }

    Rectangle {
        i-list-view := ListView {
            for parent-item[par-row] in root.model: VerticalLayout {
               GroupItemDelegate {
                    model: parent-item;
                    item-row: par-row;
                    current-item <=> root.current-item;
                    height: self.min-height;
                    selection-mode: root.selection-mode;
                    has-focus: root.has-focus;

                    item-clicked(row) => {
                        root.set-current-item(row, par-row);
                    }

                    item-pointer-event(index, event, position) => {
                        root.item-pointer-event(par-row, index, event, {
                            x: position.x,
                            y: position.y,
                        });
                    }
                }
            }
        }

        @children
    }

    public function set-current-item(row: int, par-row: int) {
        if (row < 0 || par-row < 0 || par-row >= self.model.length || row >= self.model[par-row].items.length
            || self.selection-mode == SelectionMode.Custom) {
            return;
        }

        self.current-item = { item: row, parent: par-row };
        self.current-item-changed(self.current-item);
    }
}