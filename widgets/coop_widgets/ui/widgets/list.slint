// SPDX-FileCopyrightText: 2022 Florian Blasius <co_sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { coop } from "../coop/coop.slint";

import { ScrollView } from "scroll_view.slint";
import { SelectableBase } from "selectables.slint";
import { LabelLarge, FocusBorder } from "../components/components.slint";
import { MaterialIcon, mi } from "../assets/icons/material_icons.slint";

// `ItemModel` represents a list item used by `List` and `ListView`.
export struct ItemModel := {
    // Defines the icon displayed left of the text.
    leading_icon: string,

    // Defines the text of the item.
    text: string,

    // Defines the icon displayed right of the text.
    trailing_icon: string,
}

// `ParentItemModel` represents a list item with list item children used by `List` and `ListView`.
export struct ParentItemModel := {
    // Defines the text of the item.
    text: string,

    // Defines the list of children items.
    items: [ItemModel],
}

// Default item delegate (visuell represenation of an `ItemModel`.
Item := TouchArea {
    private property <brush> foreground: coop.theme.brushes.foreground;

    in property <string> leading_icon;
    in property <string> text;
    in property <string> trailing_icon;
    in property <int> index;
    in property <int> parent_index;
    in property <{ parent: int, item: int }> current_item;
    
    height: coop.theme.sizes.small;
    forward-focus: i_focus_scope;

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
       
        key-pressed(event) => {
            if(event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    i_container := Rectangle {
       i_layout := HorizontalLayout {  
            padding_left: root.padding_left;
            padding_right: root.padding_right;
            spacing: coop.theme.spaces.small;
    
            if(leading_icon != "") : MaterialIcon {
                y: (parent.height - height) / 2;
                icon: root.leading_icon;
                icon_size: coop.theme.icons.size_medium;
                icon_color: root.foreground;
            }
    
            LabelLarge {  
                text <=> root.text;
                vertical_alignment: center;
                color: root.foreground;      
            }
    
            if(trailing_icon != "") : MaterialIcon {
                y: (parent.height - height) / 2;
                icon: root.trailing_icon;
                icon_size: coop.theme.icons.size_medium;
                icon_color: root.foreground;
            }
        }

        if(i_focus_scope.has_focus) : FocusBorder {}
    }

    states [
        pressed when root.pressed: {
            i_container.background: coop.theme.brushes.background.darker(coop.theme.state.pressed);
            foreground: coop.theme.brushes.foreground.darker(coop.theme.state.pressed);
        }
        hover when root.has_hover: {
            i_container.background: coop.theme.brushes.background.darker(coop.theme.state.hover);
            foreground: coop.theme.brushes.foreground.darker(coop.theme.state.hover);
        }
        selected when root.current_item.parent == root.parent_index && root.current_item.item == root.index: {
            i_container.background: coop.theme.brushes.background;
            foreground: coop.theme.brushes.foreground;
        }
    ]

    animate foreground { duration: coop.theme.durations.fast; }
}

// Delegate for a `ParentItemModel` it can display a `text` and a list of `ItemModels`.
ParentItem := Rectangle {
    private property <brush> foreground: coop.theme.brushes.foreground;
    in property <ParentItemModel> model;
    in property <int> item_index;
    in-out property <{ parent: int, item: int }> current_item;
    in-out property <bool> expanded: true;

    forward-focus: i_focus_scope;

    VerticalLayout {  
        spacing: coop.theme.spaces.medium;

        i_container := Rectangle {
            height: coop.theme.sizes.small;

            i_container_layout := HorizontalLayout {  
                padding_left: coop.theme.spaces.medium;
                padding_right: coop.theme.spaces.medium;
                spacing: coop.theme.spaces.medium;

                // The item is expandable if it has items.
                if(model.items.length > 0) : MaterialIcon {
                    y: (parent.height - height) / 2;
                    icon: mi.arrow_drop_down;
                    icon_size: coop.theme.icons.size_medium;
                    icon_color: root.foreground;

                    states [  
                        collapsed when !root.expanded: {
                            icon: mi.arrow-right;
                        }
                    ]
                }

                LabelLarge  {  
                    color: root.foreground;
                    text: model.text;
                    vertical_alignment: center;
                }
            }

            // The item is expandable if it has items.
            i_touch_area := TouchArea {
                enabled: root.model.items.length > 0;

                clicked => {  
                    root.expanded = !root.expanded;
                }
            }

            i_focus_scope := FocusScope {
                width: 0px; // Do not react on clicks
               
                key-pressed(event) => {
                    if(event.text == " " || event.text == "\n") {
                        i_touch_area.clicked();
                        return accept;
                    }
                    return reject;
                }
            }

            if(i_focus_scope.has_focus) : FocusBorder {}

            animate background { duration: coop.theme.durations.fast; }
        }

        if(root.expanded) : VerticalLayout {     
            for item[item_index] in model.items: Item {
                current_item <=> root.current_item;
                padding_left: i_container_layout.padding_left + i_container_layout.spacing + coop.theme.icons.size_medium;
                padding_right: i_container_layout.padding_right;
                leading_icon: item.leading_icon;
                text: item.text;
                trailing_icon: item.trailing_icon;
                index: item_index;
                parent_index: root.item_index;

                clicked => { root.current_item = { parent: root.item_index, item: item_index }; }
            }
        }     
    }

    states [
        pressed when i_touch_area.pressed: {
            i_container.background: coop.theme.brushes.background.darker(coop.theme.state.pressed);
            foreground: coop.theme.brushes.foreground.darker(coop.theme.state.pressed);
        }
        hover when i_touch_area.has_hover: {
            i_container.background: coop.theme.brushes.background.darker(coop.theme.state.hover);
            foreground: coop.theme.brushes.foreground.darker(coop.theme.state.hover);
        }
    ]

    animate foreground { duration: coop.theme.durations.fast; }
}

// `List` is a non scrollable list with a default item delegate.
export List := VerticalLayout {
    // Will be called after current is changed.
    callback current_item_changed({ parent: int, item: int });

    // Defines the list of models.
    in property <[ParentItemModel]> model;

    // Defines the current selected item.
    in-out property <{ parent: int, item: int }> current_item;
  
    spacing: coop.theme.spaces.medium;
    
    for parent_item[parent_index] in model: VerticalLayout {   
        if(model.length > 1) : ParentItem {
            model: parent_item;
            item_index: parent_index;
            current_item <=> root.current_item;
        }

        // Only one parent item.
        if(model.length == 1) : VerticalLayout {
            for item[index] in parent_item.items: Item {
                leading_icon: item.leading_icon;
                text: item.text;
                trailing_icon: item.trailing_icon;
                index: index;
                parent-index: 0;
                current_item: root.current_item;
                padding_left: coop.theme.spaces.medium;
                padding_right: coop.theme.spaces.medium;

                clicked => { 
                    root.current_item = { parent: 0, item: index } ;
                    root.current_item_changed(root.current-item);
                }
            }
        }
    }
}

// `ListView` is a scrollable variant of `List`.
export ListView := Rectangle {
    // Will be called after current is changed;
    callback current_item_changed <=> i_list.current_item_changed;

    // Defines the list of models.
    in property <[ParentItemModel]> model <=> i_list.model;

    // Defines the current selected item;
    in-out property <{ parent: int, item: int }> current_item <=> i_list.current_item;

    ScrollView {
        i_list := List {}
    }
}

// This is an internal test to check with preview.
ListViewTest := HorizontalLayout {
    padding: 16px;
    spacing: 8px;
    width: 600px;
    height: 400px;

    property <ParentItemModel> parent: {
        text: "Parent 1",
        items: [
            { leading_icon: mi.add, text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
        ]
    };

    property <ParentItemModel> parent_two: {
        text: "Parent 2",
        items: [
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
        ]
    };

    // List with on parent.
    ListView {  
        model: [
           root.parent
        ];
    }

    // List with multiple parents.
    ListView {  
        model: [
           root.parent,
           root.parent_two,
        ];
    }

    List {
        property <ParentItemModel> items: {
            text: "Parent 1",
            items: [
                { leading_icon: mi.add, text: "Item", trailing_icon: ""},
                { leading_icon: "", text: "Item", trailing_icon: ""},
                { leading_icon: "", text: "Item", trailing_icon: ""},
                { leading_icon: "", text: "Item", trailing_icon: ""},
            ]
        };
        model: [
            items
        ];
     }
}