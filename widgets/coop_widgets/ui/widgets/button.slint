// SPDX-FileCopyrightText: 2022 Florian Blasius <co-sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { Duration, Icography, Radius, Palette, Size, State, Space, Typography } from "../styling.slint";
import { FocusTouchArea } from "../components/focus-touch-area.slint";
import { MediumLabel } from "../components/label.slint";

// `ButtonBase` is used as base for buttons that can be clicked.
export component ButtonBase inherits FocusTouchArea {
     // FIXME: image
    in property <image> icon;
    in property <string> text;
    in property <brush> text-color;
    in property <brush> icon-color;
    in property <brush> border-color;
    in property <length> border-width;
    in property <brush> background;
    in property <length> icon-size: Icography.small;
    in property <float> container-scale: 1.0;
    in property <length> border-radius: Radius.large * root.container-scale;

    focus-border-radius: root.border-radius;
    padding-left: Space.large;
    padding-right: Space.large;
    min-width: i-layout.min-width;
    min-height: i-layout.min-height;

    i-background := Rectangle {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        width: root.width * root.container-scale;
        height: root.height * root.container-scale;
        background: root.background;
        border-width: root.border-width;
        border-color: root.border-color;
        border-radius: root.border-radius;
    }

    i-layout := HorizontalLayout {
        spacing: Space.small;
        padding-left: root.padding-left;
        padding-right: root.padding-right;
        alignment: center;

        if (root.icon.width > 0 && root.icon.height > 0) : Image {
            y: (parent.height - self.height) / 2;
            width: root.icon-size;
            colorize: root.icon-color;
            source: root.icon;
        }

        if (root.text != "") : Text {
            vertical-alignment: center;
            horizontal-stretch: 1;
            color: root.text-color;
            font-size: Typography.medium-label.font-size;
            font-weight: Typography.medium-label.font-weight;
            text: root.text;
        }
    }
}

export component Button {
    callback clicked <=> i-base.clicked;

    in property <string> text;
    // FIXME: image
    in property <image> icon;
    in property <bool> primary: false;
    out property <bool> has-focus: i-base.has-focus;
    out property <bool> pressed: self.enabled && i-base.pressed;
    in-out property <bool> enabled: true;

    accessible-role: button;
    accessible-label: root.text;
    min-width: max(Size.medium, i-base.min-width);
    min-height: max(Size.medium, i-base.min-height);
    vertical-stretch: 0;
    horizontal-stretch: 1;
    forward-focus: i-base;

    i-base := ButtonBase {
        enabled: root.enabled;
        background: root.primary ? Palette.primary: Palette.surface;
        text-color: root.primary ? Palette.on-primary: Palette.foreground;
        icon-color: self.text-color;
        text: root.text;
        icon: root.icon;

        animate background, text-color, container-scale { duration: Duration.fast; }
    }

    states [
        disabled when !root.enabled: {
            i-base.background: Palette.surface-disabled;
            i-base.text-color: Palette.foreground-disabled;
        }
        pressed when i-base.focus-pressed: {
            i-base.background: root.primary ? Palette.primary.darker(State.pressed) : Palette.surface.darker(State.pressed);
            i-base.text-color: root.primary ? Palette.on-primary.darker(State.pressed) : Palette.foreground.darker(State.pressed);
            i-base.container-scale: 0.98;
        }
        hover when i-base.has-hover: {
            i-base.background: root.primary ? Palette.primary.darker(State.hover) : Palette.surface.darker(State.hover);
            i-base.text-color:  root.primary ? Palette.on-primary.darker(State.hover) : Palette.foreground.darker(State.hover);
        }
    ]
}

export component OutlineButton {
    callback clicked <=> i-base.clicked;

    in property <string> text;
    // FIXME: image
    in property <image> icon;
    in property <bool> primary: false;
    out property <bool> has-focus: i-base.has-focus;
    out property <bool> pressed: self.enabled && i-base.pressed;
    in-out property <bool> enabled: true;

    accessible-role: button;
    accessible-label: root.text;
    min-width: max(Size.medium, i-base.min-width);
    min-height: max(Size.medium, i-base.min-height);
    vertical-stretch: 0;
    horizontal-stretch: 1;
    forward-focus: i-base;

    i-base := ButtonBase {
        enabled: root.enabled;
        background: root.primary ? Palette.primary: Palette.background;
        text-color: root.primary ? Palette.on-primary: Palette.foreground;
        icon-color: root.primary ? Palette.on-primary: Palette.primary;
        border-width: 1px;
        border-color: Palette.border;
        text: root.text;
        icon: root.icon;

        animate background, text-color, icon-color, border-color, container-scale { duration: Duration.fast; }
    }

    states [
        disabled when !root.enabled: {
            i-base.background: Palette.background;
            i-base.border-color: Palette.border-disabled;
            i-base.text-color: Palette.foreground-disabled;
            i-base.icon-color: Palette.foreground-disabled;
        }
        pressed when i-base.focus-pressed: {
            i-base.background: root.primary ? Palette.primary.darker(State.pressed) : Palette.background.darker(State.pressed);
            i-base.border-color: Palette.border.darker(State.pressed);
            i-base.text-color: root.primary ? Palette.on-primary.darker(State.pressed) : Palette.foreground.darker(State.pressed);
            i-base.container-scale: 0.98;
        }
        hover when i-base.has-hover: {
            i-base.background: root.primary ? Palette.primary.darker(State.hover) : Palette.background.darker(State.hover);
            i-base.border-color: Palette.border.darker(State.hover);
            i-base.text-color: root.primary ? Palette.on-primary.darker(State.hover) : Palette.foreground.darker(State.hover);
        }
    ]
}

export component RoundButton {
    callback clicked <=> i-base.clicked;

    in property <image> icon <=> i-base.icon;
    in property <string> text <=> i-base.text;
    out property <bool> has-focus: i-base.has-focus;
    out property <bool> pressed: self.enabled && i-base.pressed;
    in-out property <bool> enabled: true;
    in-out property <brush> icon-background: Palette.background;

    accessible-role: button;
    min-height: max(Size.medium, i-base.min-height);
    width: self.height;
    vertical-stretch: 0;
    horizontal-stretch: 0;

    i-base := ButtonBase {
        enabled: root.enabled;
        background: root.icon-background;
        text-color: Palette.foreground;
        icon-color: self.text-color;
        padding-left: 0px;
        padding-right: 0px;
        border-radius: max(self.width, self.height) / 2;

        animate text-color { duration: Duration.fast; }
    }

    states [
        disabled when !root.enabled: {
            i-base.text-color: Palette.foreground-disabled;
        }
        pressed when i-base.focus-pressed: {
            i-base.background: root.icon-background.darker(State.pressed);
            i-base.text-color: Palette.foreground.darker(State.pressed);
        }
        hover when i-base.has-hover: {
            i-base.background: root.icon-background.darker(State.hover);
            i-base.text-color: Palette.foreground.darker(State.hover);
        }
    ]

    animate icon-background { duration: Duration.fast; }
}

export component RoundOutlineButton {
    callback clicked <=> i-base.clicked;

    in property <image> icon <=> i-base.icon;
    in property <string> text <=> i-base.text;
    in property <bool> primary: false;
    out property <bool> has-focus: i-base.has-focus;
    out property <bool> pressed: self.enabled && i-base.pressed;
    in-out property <bool> enabled: true;

    accessible-role: button;
    // min-width: max(Size.medium, i-base.min-width);
    min-height: max(Size.medium, i-base.min-height);
    width: self.height;
    vertical-stretch: 0;
    horizontal-stretch: 0;

    i-base := ButtonBase {
        enabled: root.enabled;
        background: root.primary ? Palette.primary: Palette.background;
        border-width: 1px;
        text-color: root.primary ? Palette.on-primary: Palette.foreground;
        icon-color: self.text-color;
        border-color: Palette.border;
        padding-left: 0px;
        padding-right: 0px;
        border-radius: max(self.width, self.height) / 2;

        animate background, text-color, icon-color, border-color { duration: Duration.fast; }
    }

    states [
        disabled when !root.enabled: {
            i-base.background: Palette.background;
            i-base.border-color: Palette.border-disabled;
            i-base.text-color: Palette.foreground-disabled;
        }
        pressed when i-base.focus-pressed: {
            i-base.background: root.primary ? Palette.primary.darker(State.pressed) : Palette.background.darker(State.pressed);
            i-base.border-color: Palette.border.darker(State.pressed);
        }
        hover when i-base.has-hover: {
            i-base.background: root.primary ? Palette.primary.darker(State.hover) : Palette.background.darker(State.hover);
            i-base.border-color: Palette.border.darker(State.hover);
        }
    ]
}