// SPDX-FileCopyrightText: 2022 Florian Blasius <co_sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { Theme, Icons } from "../coop/theme.slint";
import { FocusBorder } from "../components/focus_border.slint";
import { FocusTouchArea } from "../components/focus_touch_area.slint";
import { SmallLabel } from "../components/label.slint";
import { Icon } from "../components/icon.slint";

// `SelectableBase` is used as base for widgets that can be clicked and toggle between states `unselected` and `selected`.
export component SelectableBase inherits FocusTouchArea {
    // Is called after `selected` has changed. The parameter represents the current parameter of `selected`.
    callback selected_changed(bool);

    // If set to `true` the widget is marked as selected.
    in-out property <bool> selected: false;
   
    clicked => { 
        root.selected = !root.selected;
        root.selected_changed(root.selected);
    }
}

// `CheckBox` represents a selectable check box with a text.
export component CheckBox inherits Rectangle {
    // Is called after `selected` has changed. The parameter represents the current parameter of `selected`.
    callback selected_changed <=> i_base.selected_changed;

    // Defines the label text of the `CheckBox`.
    in property <string> text <=> i_label.text;

    // If set to false the widget is disabled.
    in property <bool> enabled <=> i_base.enabled;

    // If set to `true` the widget is marked as selected.
    in-out property <bool> selected <=> i_base.selected;

    min_height: Theme.sizes.extra_small;
    horizontal-stretch: 0;
    vertical-stretch: 0;

    accessible-label <=> i_label.text;
    accessible-checkable: true;
    accessible-checked <=> root.selected;
    accessible-role: checkbox;

    i_base := SelectableBase {  
        focus_border_radius: Theme.radius.extra_small;
        
        HorizontalLayout {  
            spacing: Theme.spaces.small;
    
            VerticalLayout {  
                alignment: center;
    
                i_container := Rectangle {
                    property <length> spacing: root.text == "" ? 0px: Theme.spaces.small;
            
                    width: Theme.sizes.extra-small;
                    height: Theme.sizes.extra-small;
                    border_radius: Theme.radius.extra_small;
                    border_width: 1px;
                    border_color: Theme.brushes.border;
                    background: Theme.brushes.background;
            
                    i_icon := Icon {
                        horizontal_alignment: center;
                        vertical_alignment: center;
                        color: Theme.brushes.on_primary;
                        text: Icons.fa_var_check;
                        opacity: 0;
            
                        animate color { duration: Theme.durations.fast; }
                        animate opacity { duration: Theme.durations.fast; }
                    }
            
                    animate background { duration: Theme.durations.medium; easing: ease-in-out; }
                } 
            }
    
            i_label := SmallLabel { 
                horizontal_alignment: left;
                vertical_alignment: center;
                vertical_stretch: 1;
            }
        }
    }

    states [  
        disabled_selected when !root.enabled && root.selected: {
            i_container.background: Theme.brushes.surface_disabled;
            i_label.color: Theme.brushes.foreground_disabled;
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        disabled when !root.enabled: {
            i_container.border_color: Theme.brushes.border_disabled;
            i_label.color: Theme.brushes.foreground_disabled;
        }
        pressed_selected when i_base.focus_pressed && root.selected: {
            i_container.background: Theme.brushes.primary.darker(Theme.state.pressed);
            i_icon.color: Theme.brushes.on_primary.darker(Theme.state.pressed);
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        hover_selected when i_base.has_hover && root.selected: {
            i_container.background: Theme.brushes.primary.darker(Theme.state.hover);
            i_icon.color: Theme.brushes.on_primary.darker(Theme.state.hover);
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        pressed when i_base.focus_pressed: {
            i_container. background: Theme.brushes.background.darker(Theme.state.pressed);
            root.border_color: Theme.brushes.border.darker(Theme.state.pressed);
            i_icon.color: Theme.brushes.foreground.darker(Theme.state.pressed);
        }
        hover when i_base.has_hover: {
            i_container.background: Theme.brushes.background.darker(Theme.state.hover);
            root.border_color: Theme.brushes.border.darker(Theme.state.hover);
            i_icon.color: Theme.brushes.foreground.darker(Theme.state.hover);
        }
        selected when i_base.selected: {
            i_container.background: Theme.brushes.primary;
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
    ]
}

// `Switch` represents a selectable that can be toggled on an off.
export component Switch inherits Rectangle {
    private property <brush> foreground: Theme.brushes.foreground;
    private property <length> indicator_space: 4px;

    // Is called after `selected` has changed. The parameter represents the current parameter of `selected`.
    callback selected_changed <=> i_base.selected_changed;

    // Describes the icon of the on state.
    in property <string> on_icon;

    // Describes the icon of the off state.
    in property <string> off_icon;
    
    // If set to false the widget is disabled.
    in property <bool> enabled <=> i_base.enabled;
 
    // If set to `true` the widget is marked as selected.
    in-out property <bool> selected <=> i_base.selected;

    accessible-checkable: true;
    accessible-checked <=> root.selected;
    accessible-role: checkbox;

    width: root.height * 2;
    height: Theme.sizes.extra_small;
    vertical_stretch: 0;
    horizontal_stretch: 0;

    i_base := SelectableBase {  
        focus_border_radius: i_container.border_radius;

        i_container := Rectangle {
            width: 100%;
            height: 100%;
            background: Theme.brushes.surface;
            border_radius: i_indicator.border_radius + root.indicator_space / 2;
    
            if(root.on_icon != "") : Icon {  
                x: root.indicator_space + (i_indicator.width - self.width) / 2;
                y: (parent.height - self.height) / 2;
                text: root.on_icon;
                font_size:  Theme.icon.size.small;
                color: root.foreground;
            }
        
            if(root.off_icon != "") : Icon {  
                x: root.width - root.indicator_space - (i_indicator.width + self.width) / 2;
                y: (parent.height - self.height) / 2;
                text: root.off_icon;
                font_size:  Theme.icon.size.small;
                color: root.foreground;
            }
        
            i_indicator := Rectangle { 
                x: root.indicator_space;
                y: (parent.height - self.height) / 2;
                width: i_container.height - root.indicator_space;
                height: self.width;
                border_radius: max(self.width, self.height) / 2;
                background: Theme.brushes.foreground;
        
                animate x { duration: Theme.durations.fast; }  
            }
    
            animate background { duration: Theme.durations.fast; }
        }
    }

    states [
        disabled_selected when !root.enabled && root.selected: {
            i_container.background: Theme.brushes.surface_disabled;
            foreground: Theme.brushes.foreground_disabled;
            i_indicator.background: Theme.brushes.foreground_disabled;
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
        }
        disabled when !root.enabled: {
            i_container.background: Theme.brushes.surface_disabled;
            foreground: Theme.brushes.foreground_disabled;
            i_indicator.background: Theme.brushes.foreground_disabled;
        }
        pressed_selected when i_base.focus_pressed && root.selected: {
            i_container.background: Theme.brushes.primary.darker(Theme.state.pressed);
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: Theme.brushes.background;
            root.foreground: Theme.brushes.background;
        }
        hover_selected when i_base.has_hover && root.selected: {
            i_container.background: Theme.brushes.primary.darker(Theme.state.hover);
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: Theme.brushes.background;
            root.foreground: Theme.brushes.background;
        }
        selected when !i_base.focus_pressed && root.selected: {
            i_container.background: Theme.brushes.primary;
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: Theme.brushes.background;
            root.foreground: Theme.brushes.background;
        }
        pressed when i_base.focus_pressed: {
            i_container.background: Theme.brushes.surface.darker(Theme.state.pressed);
        }
        hover when i_base.has_hover: {
            i_container.background: Theme.brushes.surface.darker(Theme.state.hover);
        }
    ]

    animate foreground { duration: Theme.durations.fast; } 
}

// Viewer Examples

component CheckBoxExample inherits Rectangle {
    VerticalLayout {
        alignment: start;
        padding: 8px;

        CheckBox {
            text: "Check me";
        }
    }
}

component SwitchExample inherits Rectangle {
    VerticalLayout {
        padding: 8px;

        Switch {}
    }
}