// SPDX-FileCopyrightText: 2022 Florian Blasius <co_sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { coop } from "../coop/coop.slint";
import { FocusBorder } from "../components/focus_border.slint";
import { mi, MaterialIcon } from "../assets/icons/material_icons.slint";
import { Popup } from "../components/popup.slint";
import { LargeLabel } from "../components/label.slint";
import { List, GroupItemModel, ItemModel } from "../widgets/list.slint";

// `ComboBox` enables users to select a value from a list inside of a `Popuup`.
export ComboBox := Rectangle {
    // Is called after current index is changed.
    callback current_changed(int);

    // If set to `false` the widget is disabled.
    in property <bool> enabled: true;

    // Defines the list model of the combo box.
    in property <[ItemModel]> model;

    // Defines a text that is diplayed if no item is selected.
    in property <string> placeholder: "placeholder";

    // Represents the curren selected item. If there is no selection the current item is empty.
    out property <ItemModel> current_item: current_index < 0 || current_index > model.length ? {}: model[current_index];

    // Defines the index of the current selected item.
    in-out property <int> current_index: -1;
   
    accessible-role: combobox;
    accessible-value: root.current_index;

    min_width: coop.theme.sizes.large;
    min_height: coop.theme.sizes.medium;
    horizontal-stretch: 1;
    vertical-stretch: 0;

    i_container := Rectangle {
        property <brush> foreground: coop.theme.brushes.foreground;

        border_radius: coop.theme.radius.small;
        background: coop.theme.brushes.surface;

        HorizontalLayout {  
            padding_left: coop.theme.spaces.medium;
            padding_right: coop.theme.spaces.medium;
            spacing: coop.theme.spaces.small;     

            if(root.current_index >= 0 && root.current_index < model.length) : LargeLabel {  
                vertical-alignment: center;
                text: root.model[root.current-index].text;
                color: i_container.foreground;
                overflow: elide;
            }

            // placeholder
            if(root.current_index < 0) : LargeLabel {
                text <=> root.placeholder;
                vertical-alignment: center;
                color: coop.theme.brushes.border;
                overflow: elide;
            }

            i_icon := MaterialIcon {
                y: (parent.height - height) / 2;
                icon_color: i_container.foreground;
                icon_size: coop.theme.icons.size_medium;
                icon: mi.keyboard-arrow-down;
            }
        }

        animate background { duration: coop.theme.durations.fast; }
        animate foreground { duration: coop.theme.durations.fast; }
    }

    i_touch_area := TouchArea {
        enabled: root.enabled;
        clicked => { i_popup.show(); }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        
        key-pressed(event) => {
            if((event.text == " " || event.text == "\n")) {
                i_touch_area.clicked();
                return accept;
            }
            
            return reject;
        }
    }

    if(i_focus_scope.has_focus) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    i_popup := Popup {
        y: i_container.y + i_container.height + coop.theme.spaces.small; 
        width: i_container.width;

        forward_focus: i_popup_focus_scope;

        HorizontalLayout {  
            padding: 1px;

            List {  
                property <GroupItemModel> inner_model: {
                    text: "",
                    items: root.model,
                };
    
                model: [ inner_model ];
                current-item: { parent: 0, item: root.current_index };
    
                current_item_changed(item) => {  
                    root.current_index = item.item;
                    root.current_changed(root.current_index);
                }
            }
        } 

        i_popup_focus_scope := FocusScope {
            width: 0px; // Do not react on clicks
            enabled <=> root.enabled;
            
            key-pressed(event) => {
                if(event.text == Key.UpArrow) {
                    root.current_index = Math.max(root.current_index - 1, 0);
                    return accept;
                } else if(event.text == Key.DownArrow) {
                    root.current_index = Math.min(root.current_index + 1, root.model.length - 1);
                    return accept;
                } 
                
                return reject;
            }
        }
    }

    states [
        disabled when !enabled: {
            i_container.background: coop.theme.brushes.surface_disabled;
            i_container.foreground: coop.theme.brushes.foreground_disabled;
        }
        pressed when i_touch_area.pressed: {
            i_container.background:  coop.theme.brushes.surface.darker(coop.theme.state.pressed);
            i_icon.icon_color: coop.theme.brushes.foreground.darker(coop.theme.state.pressed);
            i_container.foreground: coop.theme.brushes.foreground.darker(coop.theme.state.pressed);
        }
        hover when i_touch_area.has_hover: {
            i_container.background: coop.theme.brushes.surface.darker(coop.theme.state.hover);
            i_icon.icon_color: coop.theme.brushes.foreground.darker(coop.theme.state.hover);
            i_container.foreground: coop.theme.brushes.foreground.darker(coop.theme.state.hover);
        }
    ]
}

import { CenterLayout } from "../layouts/center_layout.slint";

ComboBoxExample := CenterLayout {
    width: 200px;
    height: 200px;

    ComboBox {  
        width: 100px;
        placeholder: "Select an item";
        model: [
            {
                text: "Item 1",
            },
            {
                text: "Item 2",
            },
            {
                text: "Item 3",
            }
        ];
    
         current_changed => { debug(current_item.text); }
    }
}