import { co } from "../co/co.slint";
import { StateLayer } from "../components/components.slint";
import { MaterialIcon } from "../assets/icons/material_icon.slint";

// Internal base button.
BaseButton := Rectangle {
    callback clicked <=> i_state_layer.clicked;
    property<string> text: "text";
    property<string> icon <=> i_icon.icon;
    property<length> container_border_width <=> i_container.border_width;
    property<brush> container_border_color <=> i_container.border_color;
    property<brush> container_background <=> i_container.background;
    property<brush> label_color <=> i_label.color;
    property<length> icon_size: co.icons.size_small;
    property<length> spacing: root.icon == "" || root.text == "" ? 0px : co.spaces.medium * scale;
    property<float> scale: 1.0;
    property<bool> enabled <=> i_state_layer.enabled;

    padding_left:  co.spaces.large;
    padding_right: co.spaces.large;

    width: padding_left + i_container.icon_width + spacing + i_label.width + padding_right;
    height: co.sizes.medium;

    i_container := Rectangle {
        property<length> spacing: root.spacing;
        property<length> icon_width: root.icon != "" ? root.icon_size : 0px;

        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        width: root.width * root.scale;
        height: root.height * root.scale;
        border_radius: co.radius.large * root.scale;
        padding_left: root.padding_left * root.scale;
        padding_right: root.padding_right * root.scale;
    }

    i_icon := MaterialIcon {
        x: i_container.x + parent.padding_right;
        y: (parent.height - height) / 2;
        icon_size: root.icon_size;
        icon_color <=> root.label_color;
    }

    i_label := Text {
        x: icon == "" ? (parent.width - width) / 2 : i_container.x + parent.padding_right + i_icon.width + parent.spacing;
        y: (parent.height - height) / 2;
        color: co.brushes.foreground;
        text <=> root.text;
        horizontal-alignment: center;
        font_size: co.typo.label_medium.size;
        font_weight: co.typo.label_medium.weight;
        font_family: co.typo.label_medium.family;
    }

    i_state_layer := StateLayer {  
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        width: root.width * root.scale;
        height: root.height * root.scale;
        border_radius <=> i_container.border_radius;
        has_focus <=> i_focus_scope.has_focus;
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                 root.clicked();
                 return accept;
            }
            return reject;
        }
    }

    states [
        pressed when i_state_layer.pressed : {
            root.scale: 0.98;
        }
        disabled when !i_state_layer.enabled : {
            i_container.opacity: co.opacities.container_disabled;
            i_label.opacity: co.opacities.content_disabled;
            i_icon.opacity: co.opacities.content_disabled;
        }
    ]

    animate scale { duration: co.durations.fast; }
}

// A bordered Button with a `clicked` callback.
export OutlineButton := Rectangle {
    // Callback to handle button click.
    callback clicked <=> i_base.clicked;
    
    // Defines the text that is displayed on the button.
    property<string> text: "text";

    // Defines the optional icon of the button.
    property<string> icon <=> i_base.icon;

    // If set to false the button is disabled.
    property<bool> enabled <=> i_base.enabled;

    width <=> i_base.width;
    height <=> i_base.height;
    accessible-role: button;
    accessible-label <=> i_base.text;

    i_base := BaseButton {  
        text <=> root.text;
        container_border_width: 1px;
        container_border_color: co.brushes.border;
    }
}

// A filled Button with a `clicked` callback.
export Button := Rectangle {
    // Callback to handle button click.
    callback clicked <=> i_base.clicked;
    
    // Defines the text that is displayed on the button.
    property<string> text: "text";

    // Defines the optional icon of the button.
    property<string> icon <=> i_base.icon;

    // If set to `true` the background of the button will uses `co.brushes.primary`.
    property<bool> primary: false;

    // If set to false the button is disabled.
    property<bool> enabled <=> i_base.enabled;

    width <=> i_base.width;
    height <=> i_base.height;
    accessible-role: button;
    accessible-label <=> i_base.text;

    i_base := BaseButton {  
        text <=> root.text;
        container_background: root.primary ? co.brushes.primary : co.brushes.surface;
        label_color: root.primary ? co.brushes.on_primary : co.brushes.foreground;
    }

    states [
        primary_disabled when !enabled && primary : {
            i_base.label_color: co.brushes.foreground;
        }
    ]
}

// A button that only displays an icon.
export IconButton := Rectangle {
    // Callback to handle button click.
    callback clicked <=> i_state_layer.clicked;

    // Defines the optional icon of the button.
    property<string> icon <=> i_icon.icon;

    // If set to false the button is disabled.
    property<bool> enabled <=> i_state_layer.enabled;

    width: co.sizes.medium;
    height: width;
    accessible-role: button;

    i_icon := MaterialIcon {
       x: (parent.width - width) / 2;
       y: (parent.height - height) / 2;
       icon_size: co.icons.size_medium;
       icon_color: co.brushes.foreground;
    }

    i_state_layer := StateLayer {  
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        width: co.sizes.large;
        height: width;
        border_radius: max(width, height) / 2;
        has_focus <=> i_focus_scope.has_focus;
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                 root.clicked();
                 return accept;
            }
            return reject;
        }
    }

    states [
        disabled when !i_state_layer.enabled : {
            i_icon.opacity: co.opacities.container_disabled;
        }
    ]
}