import { co } from "../co/co.slint";
import { StateLayer } from "../components/components.slint";
import { MaterialIcon } from "../assets/icons/material_icon.slint";
import { mi } from "../assets/icons/material_icons.slint";

ClearButton := TouchArea {
    width: i_icon.width;
    height: i_icon.height;

    i_icon := MaterialIcon {
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        icon_size: co.icons.size_small;
        icon_color: co.brushes.foreground;
        icon: mi.clear;
    }

    state_layer := MaterialIcon {
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        icon_size:  i_icon.icon_size;
        icon_color: co.brushes.state;
        icon: i_icon.icon;
        opacity: 0;

        animate opacity { duration: co.durations.fast; easing: ease_in_out; }
    }

    states [
        pressed when root.pressed : {
            state_layer.opacity: co.opacities.state_pressed;
        }
        hover when root.has_hover : {
            state_layer.opacity: co.opacities.state_hover;
        }
        disabled when !root.enabled : {
            i_icon.opacity: co.opacities.container_disabled;
        }
    ]
}

// A single line text input widget.
export TextLine := Rectangle {
    // Defines the icon that is displayed in front of the text.
    property<string> icon <=> i_icon.icon;

    // Defines a text that is diplayed if text is empty.
    property<string> placeholder: "placeholder";

    // The text that is displayed and can changed by text input.
    property<string> text <=> i_input.text;

    // If set to false the widget is disabled.
    property<bool> enabled <=> i_input.enabled;

    // If set to true a clear all button is displayed.
    property<bool> clear_all: false;

    // If set to true the text cannot be selected or changed by keyboard input.
    property read-only <=> i_input.read-only;

    // Is emitted after text is changed.
    callback edited <=> i_input.edited;

    min_width: 168px;
    height: co.sizes.medium;
    forward-focus: i_input;

    i_container := Rectangle {
        width: 100%;
        height: 100%;

        border_radius: co.radius.small;
        background: co.brushes.surface;
    }

    i_state_layer := StateLayer {  
        enabled <=> root.enabled;
        border_radius: i_container.border_radius;
        has_focus <=> i_input.has_focus;
    }

    i_layout := HorizontalLayout {  
        padding_left: co.spaces.medium;
        padding_right: co.spaces.medium;
        spacing: co.spaces.small;

        i_icon := MaterialIcon {
            y: (parent.height - height) / 2;
            icon_color: co.brushes.foreground;
            icon_size: co.icons.size_medium;
        }

        Rectangle {  
            clip: true;

            i_input := TextInput {
                property <length> computed_x;
                property <length> padding-outer: i_layout.padding-left + i_layout.padding-right;
    
                x: min(0px, max(parent.width - width, computed_x));
                width: max(parent.width, preferred-width);
                height: 100%;
                color:co.brushes.foreground;
                vertical-alignment: center;
                font_size: co.typo.label_medium.size;
                font_weight: co.typo.label_medium.weight;
                font_family: co.typo.label_medium.family;
    
                cursor-position-changed(cpos) => {
                    if (cpos.x + computed_x < padding-outer) {
                        computed_x = - cpos.x + padding-outer;
                    } else if (cpos.x + computed_x > parent.width - padding-outer) {
                        computed_x = parent.width - cpos.x - padding-outer;
                    }
                }
            }

            if (text == "") : Text {
                text <=> root.placeholder;
                y: (parent.height - height) / 2;
                color: co.brushes.border;
                opacity: i_input.opacity;
                font_size: co.typo.label_medium.size;
                font_weight: co.typo.label_medium.weight;
                font_family: co.typo.label_medium.family;
            }
        }

        if(clear_all) : ClearButton {
            enabled: root.enabled;
            y: (parent.height - height) / 2;
            clicked => { text = ""; }
        }
    }

    states [
        disabled when !i_state_layer.enabled : {
            i_container.opacity: co.opacities.container_disabled;
            i_input.opacity: co.opacities.content_disabled;
            i_icon.opacity: co.opacities.content_disabled;
        }
    ]
}