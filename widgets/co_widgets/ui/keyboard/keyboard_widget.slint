// SPDX-FileCopyrightText: 2022 Florian Blasius <flovanpt@posteo.de>
// SPDX-License-Identifier: MIT

import { TextLine, Button, OutlineButton, RoundButton, RoundOutlineButton } from "../widgets/widgets.slint";
import { co } from "../co/co.slint";
import { mi } from "../assets/icons/material_icons.slint";

// Helps to handle keyboard actions that cannot be done at the moment with slint.
//
// The adapter need to exported from the app main slint file and the backspace callback must be implemented in code.
export global KeyboardAdapter := {
    // Removes the last character of the given string and returns the result.
    callback backspace(string) -> string;
}

KeyboardButton := RoundOutlineButton {
    width: co.settings.minimize ? co.sizes.small : co.sizes.medium;
}

// Defines the model of a key of the `Keyboard`.
export struct KeyModel := {
    l: string, 
    u: string, 
    a_l: string, 
    a_u: string,
}

// Used to define a button layout for the  `Keyboard`.
export struct KeyboardLayout := {
    row_one:  [KeyModel],
    row_two:  [KeyModel],
    row_three:  [KeyModel],
}

// A on screen `Keyboard` widget.
export Keyboard := Rectangle {
    // The keyboard closes.
    callback close(string, string);

    // Opens the keyboard with the giben key and text.
    callback open(string, string, string, string);

    // FIXME: internal
    callback key_enter(string);
    
    // The text that can be manipulated by the `Keyboard`.
    property<string> text <=> i_text_line.text;

    // Placeholder of the inner text line.
    property<string> placeholder <=> i_text_line.placeholder;

    // Icon of the inner text line.
    property<string> icon <=> i_text_line.icon;

    // If set to `true` the keyboard is in shift mode.
    property<bool> shift;

    // FIME: private with new syntax
    property <string> key;

    // If set to `true` the keyboard will display alternatives keys.
    property<bool> extra;

    // Defines the button layout of the keyboard.
    property <KeyboardLayout> layout: {
        row_one: [ 
            { l: "q", u : "Q", a_l: "1", a_u: "[" },
            { l: "w", u : "W", a_l: "2", a_u: "]" },
            { l: "e", u : "E", a_l: "3", a_u: "{" },
            { l: "r", u : "R", a_l: "4", a_u: "}" },
            { l: "t", u : "T", a_l: "5", a_u: "#" },
            { l: "y", u : "Y", a_l: "6", a_u: "%" },
            { l: "u", u : "U", a_l: "7", a_u: "^" },
            { l: "i", u : "I", a_l: "8", a_u: "*" },
            { l: "o", u : "O", a_l: "9", a_u: "+" },
            { l: "p", u : "P", a_l: "0", a_u: "=" },  
        ],
        row_two: [
            { l: "a", u : "A", a_l: "-", a_u: "_" },
            { l: "s", u : "S", a_l: "/", a_u: "\\" },
            { l: "d", u : "D", a_l: ":", a_u: "|" },
            { l: "g", u : "G", a_l: ";", a_u: "~" },
            { l: "h", u : "H", a_l: "(", a_u: "<" },
            { l: "j", u : "J", a_l: ")", a_u: ">" },
            { l: "k", u : "K", a_l: "&", a_u: "$" },
            { l: "l", u : "L", a_l: "@", a_u: "€" },
        ],
        row_three: [
            { l: "z", u : "Z", a_l: ".", a_u: "." },
            { l: "x", u : "X", a_l: ",", a_u: "," },
            { l: "c", u : "C", a_l: "?", a_u: "?" },
            { l: "v", u : "V", a_l: "'", a_u: "+" },
            { l: "b", u : "B", a_l: "$", a_u: "-" },
            { l: "n", u : "N", a_l: "€", a_u: "=" },
            { l: "m", u : "M", a_l: ".", a_u: "." },
        ],
    };

    VerticalLayout {  
        alignment: center;
        spacing: co.spaces.small;
        padding: co.spaces.large;


        VerticalLayout {  
            min_height: co.sizes.large;
            vertical-stretch: 0;
            alignment: center;

            i_text_line := TextLine {
               
                read_only: true;
            }
        }  

        i_row_one := HorizontalLayout {
            spacing: co.spaces.small;
            alignment: center;

            for key in layout.row_one : KeyboardButton {
                text: root.extra ? root.shift ? key.a_u : key.a_l : root.shift ? key.u : key.l;
                clicked => { root.key_enter(text); }
            }
        }
        i_row_two := HorizontalLayout {
            spacing: co.spaces.small;
            alignment: center;

            for key in layout.row_two : KeyboardButton {
                text: root.extra ? root.shift ? key.a_u : key.a_l : root.shift ? key.u : key.l;
                clicked => { root.key_enter(text); }
            }
        }
        i_row_three := HorizontalLayout {
            spacing: co.spaces.small;
            alignment: center;

            // shift
            KeyboardButton {  
                icon: mi.keyboard-arrow-up;
                clicked => { root.shift = !root.shift; }
            }

            for key in layout.row_three : KeyboardButton {
                text: root.extra ? root.shift ? key.a_u : key.a_l : root.shift ? key.u : key.l;
                clicked => { root.key_enter(text); }
            }

            // backspace
            KeyboardButton {  
                icon: mi.backspace;
                clicked => { root.text = KeyboardAdapter.backspace(root.text); }
            }
        }
        i_row_fore := HorizontalLayout {
            spacing: co.spaces.small;
            alignment: center;

            // switch keyboard
            KeyboardButton {
                icon: mi.calculate;
                clicked => { root.extra = !root.extra; }
            }

            // space button
            Button {  
                width: 120px;
                height: co.settings.minimize ? co.sizes.small : co.sizes.medium;
                text: "";
                clicked => { root.key_enter(" "); }
            }

            // enter / close keyboard
            KeyboardButton {
                primary: true;
             
                icon: mi.keyboard_return;
                clicked => { root.close(root.key, root.text); }
            }
        }
    }

    open(key, text, placeholder, icon) => {  
        root.key = key;
        root.text = text;
        root.placeholder = placeholder;
        root.icon = icon;
    }

    key_enter(char) => {  
        root.text = root.text + char;
        root.shift = false;
    }
}