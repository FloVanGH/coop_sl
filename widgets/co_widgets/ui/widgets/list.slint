// SPDX-FileCopyrightText: 2022 Florian Blasius <co_sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { co } from "../co/co.slint";

import { ScrollView } from "scroll_view.slint";
import { SelectableBase } from "selectables.slint";
import { LabelLarge, LabelMedium, FocusBorder } from "../components/components.slint";
import { MaterialIcon, mi } from "../assets/icons/material_icons.slint";

// Model definition of a `Item`.
export struct ItemModel := {
    leading_icon: string,
    text: string,
    trailing_icon: string,
}

// A model with `ItemModel` chilren.
export struct ParentItemModel := {
    text: string,
    items: [ItemModel],
}

// Default item delegate (visuell represenation of an `ItemModel`.
Item := TouchArea {
    property <string> leading_icon;
    property <string> text;
    property <string> trailing_icon;
    property <brush> foreground: co.brushes.foreground;
    property <int> index;
    property <int> parent_index;
    property <{ parent: int, item: int }> current_item;

    height: co.sizes.small;
    forward-focus: i_focus_scope;

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
       
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    i_container := Rectangle {
       i_layout := HorizontalLayout {  
            padding_left: root.padding_left;
            padding_right: root.padding_right;
            spacing: co.spaces.small;
    
            if(leading_icon != "") : MaterialIcon {
                y: (parent.height - height) / 2;
                icon <=> root.leading_icon;
                icon_size: co.icons.size_medium;
                icon_color: root.foreground;
            }
    
            LabelMedium {  
                text <=> root.text;
                vertical_alignment: center;
                color: root.foreground;
            }
    
            if(trailing_icon != "") : MaterialIcon {
                y: (parent.height - height) / 2;
                icon <=> root.trailing_icon;
                icon_size: co.icons.size_medium;
                icon_color: root.foreground;
            }
        }

        if(i_focus_scope.has_focus) : FocusBorder {}
    }

    states [
        pressed when root.pressed : {
            i_container.background: co.brushes.background.darker(co.state.pressed);
            foreground: co.brushes.foreground.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            i_container.background: co.brushes.background.darker(co.state.hover);
            foreground: co.brushes.foreground.darker(co.state.hover);
        }
        selected when root.current_item.parent == root.parent_index && root.current_item.item == root.index : {
            i_container.background: co.brushes.background;
            foreground: co.brushes.foreground;
        }
    ]

    animate foreground { duration: co.durations.fast; }
}

// Delegate for a `ParentItemModel` it can display a `text` and a list of `ItemModels`.
ParentItem := Rectangle {
    property <ParentItemModel> model;
    property <bool> expanded: true;
    property <brush> foreground: co.brushes.foreground;
    property <int> item_index;
    property <{ parent: int, item: int }> current_item;

    forward-focus: i_focus_scope;

    VerticalLayout {  
        spacing: co.spaces.medium;

        i_container := Rectangle {
            height: co.sizes.small;

            i_container_layout := HorizontalLayout {  
                padding_left: co.spaces.medium;
                padding_right: co.spaces.medium;
                spacing: co.spaces.medium;

                // The item is expandable if it has items.
                if(model.items.length > 0) : MaterialIcon {
                    y: (parent.height - height) / 2;
                    icon: mi.arrow_drop_down;
                    icon_size: co.icons.size_medium;
                    icon_color: root.foreground;

                    states [  
                        collapsed when !root.expanded : {
                            icon: mi.arrow-right;
                        }
                    ]
                }

                LabelLarge  {  
                    color: root.foreground;
                    text: model.text;
                    vertical_alignment: center;
                }
            }

            // The item is expandable if it has items.
            i_touch_area := TouchArea {
                enabled: root.model.items.length > 0;

                clicked => {  
                    root.expanded = !root.expanded;
                }
            }

            i_focus_scope := FocusScope {
                width: 0px; // Do not react on clicks
               
                key-pressed(event) => {
                    if (event.text == " " || event.text == "\n") {
                        i_touch_area.clicked();
                        return accept;
                    }
                    return reject;
                }
            }

            if(i_focus_scope.has_focus) : FocusBorder {}

            animate background { duration: co.durations.fast; }
        }

        if(root.expanded) : VerticalLayout {     
            for item[item_index] in model.items : Item {
                current_item <=> root.current_item;
                padding_left: i_container_layout.padding_left + i_container_layout.spacing + co.icons.size_medium;
                padding_right: i_container_layout.padding_right;
                leading_icon: item.leading_icon;
                text: item.text;
                trailing_icon: item.trailing_icon;
                index: item_index;
                parent_index: root.item_index;

                clicked => { root.current_item = { parent: root.item_index, item: item_index }; }
            }
        }     
    }

    states [
        pressed when i_touch_area.pressed : {
            i_container.background: co.brushes.background.darker(co.state.pressed);
            foreground: co.brushes.foreground.darker(co.state.pressed);
        }
        hover when i_touch_area.has_hover : {
            i_container.background: co.brushes.background.darker(co.state.hover);
            foreground: co.brushes.foreground.darker(co.state.hover);
        }
    ]

    animate foreground { duration: co.durations.fast; }
}

// A non scrollable list with `Item` as default delegate.
export List := VerticalLayout {
    // Defines the list of models.
    property <[ParentItemModel]> model;

    // Defines the current selected item;
    property <{ parent: int, item: int }> current_item;
  
    spacing: co.spaces.medium;
    
    for parent_item[parent_index] in model : VerticalLayout {   
        if(model.length > 1) : ParentItem {
            model: parent_item;
            item_index: parent_index;
            current_item <=> root.current_item;
        }

        // Only one parent item.
        if(model.length == 1) : VerticalLayout {
            for item[index] in parent_item.items : Item {
                leading_icon: item.leading_icon;
                text: item.text;
                trailing_icon: item.trailing_icon;
                index: index;
                parent-index: 0;
                current_item: root.current_item;

                clicked => { root.current_item = { parent: 0, item: index } }
            }
        }
    }
}

// A scrollable variant of `List`.
export ListView := Rectangle {
   // Defines the list of models.
    property <[ParentItemModel]> model <=> i_list.model;

     // Defines the current selected item;
     property <{ parent: int, item: int }> current_item <=> i_list.current_item;

    ScrollView {
        i_list := List {}
    }
}

// This is an internal test to check with preview.
ListViewText := HorizontalLayout {
    padding: 16px;
    spacing: 8px;
    width: 600px;
    height: 400px;

    property <ParentItemModel> parent: {
        text: "Parent 1",
        items: [
            { leading_icon: mi.add, text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
        ]
    };

    property <ParentItemModel> parent_two: {
        text: "Parent 2",
        items: [
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
            { leading_icon: "", text: "Item", trailing_icon: ""},
        ]
    };

    // List with on parent.
    ListView {  
        model: [
           root.parent
        ];
    }

    // List with multiple parents.
    ListView {  
        model: [
           root.parent,
           root.parent_two,
        ];
    }
}