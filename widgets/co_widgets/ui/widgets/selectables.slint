// SPDX-FileCopyrightText: 2022 Florian Blasius <flovanpt@posteo.de>
// SPDX-License-Identifier: MIT

import { co } from "../co/co.slint";
import { LabelSmall, FocusBorder } from "../components/components.slint";
import { MaterialIcon, mi } from "../assets/icons/material_icons.slint";

// `SelectableBase` is used as base for widgets that can be clicked and toggle between states `unselected` and `selected`.
export SelectableBase := Rectangle {
    // Is called after `selected` has changed. The parameter represents the current parameter of `selected`.
    callback selected_changed(bool);

    // If set to `true` the widget is marked as selected.
    property <bool> selected: false;

    // If set to `false` the widget is disabled.
    property <bool> enabled <=> i_touch_area.enabled;

    // If set to `true` the widget has pointer hover.
    property <bool> has_hover <=> i_touch_area.has_hover;

    // If set to `true` the widget has keyboard focus.
    property <bool> has_focus <=> i_focus_scope.has_focus;

    // If `true` the widget is pressed.
    property <bool> pressed <=> i_touch_area.pressed;

    forward_focus: i_focus_scope;

    i_touch_area := TouchArea {  
        clicked => { 
            root.selected = !root.selected;
            root.selected_changed(root.selected);
         }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                i_touch_area.clicked();
                return accept;
            }
            return reject;
        }
    }
}

// `CheckBox` represents a selectable check box with a text.
export CheckBox := SelectableBase {
    // Defines the label text of the `CheckBox`.
    property <string> text <=> i_label.text;

    min_height: co.sizes.extra_small;
    horizontal-stretch: 0;
    vertical-stretch: 0;

    accessible-label <=> i_label.text;
    accessible-checkable: true;
    accessible-checked <=> selected;
    accessible-role: checkbox;

    HorizontalLayout {  
        spacing: co.spaces.small;

        VerticalLayout {  
            alignment: center;

            i_container := Rectangle {
                property <length> spacing: root.text == "" ? 0px : co.spaces.small;
        
                width: co.sizes.extra-small;
                height: co.sizes.extra-small;
                border_radius: co.radius.extra_small;
                border_width: 1px;
                border_color: co.brushes.border;
                background: co.brushes.background;
        
                i_icon := MaterialIcon {
                    x: (parent.width - width) / 2;
                    y: (parent.height - height) / 2;
                    icon_color: co.brushes.on_primary;
                    icon: mi.check;
                    opacity: 0;
        
                    animate icon_color { duration: co.durations.fast; }
                    animate opacity { duration: co.durations.fast; }
                }
        
                animate background { duration: co.durations.medium; easing: ease-in-out; }
            } 
        }

        i_label := LabelSmall { 
            horizontal_alignment: left;
            vertical_alignment: center;
            vertical_stretch: 1;
        }
    }

    if(root.has_focus) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: co.radius.small;
    }

    states [  
        disabled_selected when !enabled && root.selected : {
            i_container.background: co.brushes.surface_disabled;
            i_label.color: co.brushes.foreground_disabled;
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        disabled when !enabled : {
            i_container.border_color: co.brushes.border_disabled;
            i_label.color: co.brushes.foreground_disabled;
        }
        pressed_selected when root.pressed && root.selected : {
            i_container.background: co.brushes.primary.darker(co.state.pressed);
            i_icon.icon_color: co.brushes.on_primary.darker(co.state.pressed);
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        hover_selected when root.has_hover && root.selected : {
            i_container.background: co.brushes.primary.darker(co.state.hover);
            i_icon.icon_color: co.brushes.on_primary.darker(co.state.hover);
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
        pressed when root.pressed : {
            i_container. background: co.brushes.background.darker(co.state.pressed);
            root.border_color: co.brushes.border.darker(co.state.pressed);
            i_icon.icon_color: co.brushes.foreground.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            i_container.background: co.brushes.background.darker(co.state.hover);
            root.border_color: co.brushes.border.darker(co.state.hover);
            i_icon.icon_color: co.brushes.foreground.darker(co.state.hover);
        }
        selected when root.selected : {
            i_container.background: co.brushes.primary;
            i_container.border_width: 0px;
            i_icon.opacity: 1;
        }
    ]
}

// `Switch` represents a selectable that can be toggled on an off.
export Switch := SelectableBase {
    // Describes the icon of the on state.
    property <string> on_icon;

    // Describes the icon of the off state.
    property <string> off_icon;

    // FIXEME: private with new syntax
    property <brush> foreground: co.brushes.foreground;

    // FIXEME: private with new syntax
    property <length> indicator_space: 4px;

    width: height * 2;
    height: co.sizes.extra_small;
    vertical_stretch: 0;
    horizontal_stretch: 0;

    accessible-checkable: true;
    accessible-checked <=> selected;
    accessible-role: checkbox;

    i_container := Rectangle {
        width: 100%;
        height: 100%;
        background: co.brushes.surface;
        border_radius: i_indicator.border_radius + indicator_space / 2;

        if(root.on_icon != "") : MaterialIcon {  
            x: root.indicator_space + (i_indicator.width - width) / 2;
            y: (parent.height - height) / 2;
            icon <=> root.on_icon;
            icon_size: co.icons.size_small;
            icon_color: root.foreground;
        }
    
        if(root.off_icon != "") : MaterialIcon {  
            x: root.width - root.indicator_space - (i_indicator.width + width) / 2;
            y: (parent.height - height) / 2;
            icon <=> root.off_icon;
            icon_size: co.icons.size_small;
            icon_color: root.foreground;
        }
    
        i_indicator := Rectangle { 
            x: root.indicator_space;
            y: (parent.height - height) / 2;
            width: i_container.height - root.indicator_space;
            height: width;
            border_radius: max(width, height) / 2;
            background: co.brushes.foreground;
    
            animate x { duration: co.durations.fast; }  
        }

        animate background { duration: co.durations.fast; }
    }

    if(root.has_focus) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    states [
        disabled_selected when !enabled && root.selected : {
            i_container.background: co.brushes.surface_disabled;
            foreground: co.brushes.foreground_disabled;
            i_indicator.background: co.brushes.foreground_disabled;
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
        }
        disabled when !enabled : {
            i_container.background: co.brushes.surface_disabled;
            foreground: co.brushes.foreground_disabled;
            i_indicator.background: co.brushes.foreground_disabled;
        }
        pressed_selected when root.pressed && root.selected : {
            i_container.background: co.brushes.primary.darker(co.state.pressed);
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: co.brushes.background;
            root.foreground: co.brushes.background;
        }
        hover_selected when root.has_hover && root.selected : {
            i_container.background: co.brushes.primary.darker(co.state.hover);
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: co.brushes.background;
            root.foreground: co.brushes.background;
        }
        selected when !root.pressed && root.selected : {
            i_container.background: co.brushes.primary;
            i_indicator.x: i_container.x + i_container.width - i_indicator.width - root.indicator_space;
            i_indicator.background: co.brushes.background;
            root.foreground: co.brushes.background;
        }
        pressed when root.pressed : {
            i_container.background: co.brushes.surface.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            i_container.background: co.brushes.surface.darker(co.state.hover);
        }
    ]

    animate foreground { duration: co.durations.fast; } 
}

// Viewer Examples

CheckBoxExample := Rectangle {
    VerticalLayout {
        alignment: start;
        padding: 8px;

        CheckBox {
            text: "Check me";
        }
    }
}

SwitchExample := Rectangle {
    VerticalLayout {
        padding: 8px;

        Switch {}
    }
}