import { co } from "../co/co.slint";
import { FocusBorder, LabelMedium } from "../components/components.slint";
import { MaterialIcon } from "../assets/icons/material_icons.slint";
// Base of default buttons.
export ButtonBase := TouchArea {
    // Defines the icon of the button.
    property<string> icon: "";

    // Defines the text of the button.
    property<string> text: "";

    // Defines the color of the icon and text.
    property<brush> color;

    // Defines the border color.
    property<brush> border_color;

    // Defines the border width.
    property<length> border_width;

    // Defines the bacground color.
    property<brush> background;

    // Defines the size of the icon.
    property<length> icon_size: co.icons.size_small;

    // Defines the space between icon and text.
    property<length> spacing: root.icon == "" || root.text == "" ? 0px : co.spaces.small;

    width: (padding_left + (root.icon == "" ? 0px : root.icon_size) + spacing + i_size_helper.width + padding_right);
    height: co.sizes.medium;
    accessible-role: button;
    padding_left:  co.spaces.large;
    padding_right: co.spaces.large;
    forward_focus: i_focus_scope;

    i_size_helper := Text {
        x: 0px;
        visible: false;
        font_size: co.typo.label_medium.size;
        font_weight: co.typo.label_medium.weight;
        font_family: co.typo.label_medium.family;
        text: root.text;
    }

    i_container := Rectangle {
        property<float> scale: 1.0;

        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        width: root.width * scale;
        height: root.height * scale;
        background: root.background;
        border_width: root.border_width;
        border_color: root.border_color;
        border_radius: co.radius.large * scale;

        states [
            pressed when root.pressed : {
                scale: 0.96;
            }
        ]

        animate scale { duration: co.durations.fast; }
    }

    HorizontalLayout { 
        alignment: center;
        spacing: root.spacing;

        if(root.icon != "") : MaterialIcon {
            y: (parent.height - height) / 2;
            icon_size: root.icon_size ;
            icon_color: root.color;
            icon: root.icon;
        }

        if(root.text != "") : Text {
            vertical-alignment: center;
            color: root.color;
            font_size: co.typo.label_medium.size;
            font_weight: co.typo.label_medium.weight;
            font_family: co.typo.label_medium.family;
            text: root.text;
        }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    if(i_focus_scope.has_focus) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    animate color { duration: co.durations.fast;  }
    animate background { duration: co.durations.fast; }
    animate border_color { duration: co.durations.fast; }
}

// Default filled button.
export Button := ButtonBase {
    // If set to `true` the background will set to `co.brushes.primary`.
    property<bool> primary: false;

    background: primary ? co.brushes.primary : co.brushes.surface;
    color: primary ? co.brushes.on_primary : co.brushes.foreground;

    states [
        disabled when !enabled : {
            root.background: co.brushes.surface_disabled;
            root.color: co.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            root.background: primary ? co.brushes.primary.darker(co.state.pressed) : co.brushes.surface.darker(co.state.pressed);
            root.color:  primary ? co.brushes.on_primary.darker(co.state.pressed) : co.brushes.foreground.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            root.background: primary ? co.brushes.primary.darker(co.state.hover) : co.brushes.surface.darker(co.state.hover);
            root.color:  primary ? co.brushes.on_primary.darker(co.state.hover) : co.brushes.foreground.darker(co.state.hover);
        }
    ]
}

export OutlineButton := ButtonBase {
  // If set to `true` the background will set to `co.brushes.primary`.
  property<bool> primary: false;

  background: primary ? co.brushes.primary : co.brushes.background;
  border_width: 1px;
  color: primary ? co.brushes.on_primary : co.brushes.foreground;
  border_color: co.brushes.border;

  states [
      disabled when !enabled : {
          root.background: co.brushes.background;
          root.border_color: co.brushes.border_disabled;
          root.color: co.brushes.foreground_disabled;
      }
      pressed when root.pressed : {
          background: primary ? co.brushes.primary.darker(co.state.pressed) : co.brushes.background.darker(co.state.pressed);
          root.border_color: co.brushes.border.darker(co.state.pressed);
          root.color: primary ? co.brushes.on_primary.darker(co.state.pressed) : co.brushes.foreground.darker(co.state.pressed);
      }
      hover when root.has_hover : {
          background: primary ? co.brushes.primary.darker(co.state.hover) : co.brushes.background.darker(co.state.hover);
          root.border_color: co.brushes.border.darker(co.state.hover);
          root.color: primary ? co.brushes.on_primary.darker(co.state.hover) : co.brushes.foreground.darker(co.state.hover);
      }
  ]
}

// Base of round buttons.
export RoundButtonBase := TouchArea {
    // Defines the icon of the button.
    property<string> icon: "";

    // Defines the text of the button.
    property<string> text: "";

    // Defines the color of the icon and text.
    property<brush> color;

    // Defines the border color.
    property<brush> border_color;

    // Defines the border width.
    property<length> border_width;

    // Defines the bacground color.
    property<brush> background;

    width: co.sizes.medium;
    height: width;
    accessible-role: button;

    i_container := Rectangle {
        width: 100%;
        height: 100%;
        border_radius:(co.settings.minimize ? co.sizes.small : co.sizes.medium) / 2;
        background: root.background;
        border_width: root.border_width;
        border_color: root.border_color;

        if(root.icon != "") : MaterialIcon {
            x: (parent.width - width) / 2;
            y: (parent.height - height) / 2;
            icon_size: co.icons.size_medium;
            icon_color: root.color;
            icon: root.icon;
        }

        if(root.text != "") : Text {
            color: root.color;
            x: (parent.width - width) / 2;
            y: (parent.height - height) / 2;
            font_size: co.typo.label_medium.size;
            font_weight: co.typo.label_medium.weight;
            font_family: co.typo.label_medium.family;
            text: root.text;
        }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    if(i_focus_scope.has_focus && !co.settings.minimize) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    animate color { duration: co.durations.fast;  }
    animate background { duration: co.durations.fast; }
    animate border_color { duration: co.durations.fast; }
}

// A round button.
export RoundButton := RoundButtonBase {
    background: co.brushes.background;
    color: co.brushes.foreground;

    states [
        disabled when !enabled : {
            root.color: co.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            root.background: co.brushes.background.darker(co.state.pressed);
            root.color: co.brushes.foreground.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            root.background: co.brushes.background.darker(co.state.hover);
            root.color: co.brushes.foreground.darker(co.state.hover);
        }
    ]
}

// A round outline button.
export RoundOutlineButton := RoundButtonBase {
    // If set to `true` the background will set to `co.brushes.primary`.
    property<bool> primary: false;

    background: primary ? co.brushes.primary : co.brushes.background;
    border_width: 1px;
    color: primary ? co.brushes.on_primary : co.brushes.foreground;
    border_color: co.brushes.border;

    states [
        disabled when !enabled : {
            root.background: co.brushes.background;
            root.border_color: co.brushes.border_disabled;
            root.color: co.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            background: primary ? co.brushes.primary.darker(co.state.pressed) : co.brushes.background.darker(co.state.pressed);
            root.border_color: co.brushes.border.darker(co.state.pressed);
            root.color: primary ? co.brushes.on_primary.darker(co.state.pressed) : co.brushes.foreground.darker(co.state.pressed);
        }
        hover when root.has_hover : {
            background: primary ? co.brushes.primary.darker(co.state.hover) : co.brushes.background.darker(co.state.hover);
            root.border_color: co.brushes.border.darker(co.state.hover);
            root.color: primary ? co.brushes.on_primary.darker(co.state.hover) : co.brushes.foreground.darker(co.state.hover);
        }
    ]
}
