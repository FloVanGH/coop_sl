// SPDX-FileCopyrightText: 2022 Florian Blasius <co_sl@tutanota.com>
// SPDX-License-Identifier: MIT

import { co } from "../co/co.slint";
import { FocusBorder } from "../components/focus_border.slint";
import { LabelMedium } from "../components/label.slint";
import { MaterialIcon } from "../assets/icons/material_icons.slint";

// `ButtonBase` is used as base for buttons that can be clicked.
export ButtonBase := TouchArea {
    // Used to set an optional icon on the button. Uses material icons check the `mi` global.
    property <string> icon: "";

    // Used to set the display text of the button.
    property <string> text: "";

    // Defines the color of the icon and text.
    property <brush> color;

    // Defines the border color.
    property <brush> border_color;

    // Defines the border width.
    property <length> border_width;

    // Defines the bacground color.
    property <brush> background;

    // Defines the size of the icon.
    property <length> icon_size: co.theme.icons.size_small;

    min_height: co.theme.sizes.medium;
    forward_focus: i_focus_scope;

    i_container := Rectangle {
        property <float> scale: 1.0;

        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        width: root.width * scale;
        height: root.height * scale;
        background: root.background;
        border_width: root.border_width;
        border_color: root.border_color;
        border_radius: co.theme.radius.large * scale;

        states [
            pressed when root.pressed : {
                scale: 0.96;
            }
        ]

        animate scale { duration: co.theme.durations.fast; }
    }

    HorizontalLayout {  
        spacing: co.theme.spaces.small;
        padding_left:  co.theme.spaces.large;
        padding_right: co.theme.spaces.large;
        alignment: center;

        if(root.icon != "") : MaterialIcon {
            y: (parent.height - height) / 2;
            icon_size: root.icon_size;
            icon_color: root.color;
            icon: root.icon;
        }

        if(root.text != "") : Text {
            vertical-alignment: center;
            color: root.color;
            font_size: co.theme.typo.label_medium.size;
            font_weight: co.theme.typo.label_medium.weight;
            font_family: co.theme.typo.label_medium.family;
            text: root.text;
        }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    if(i_focus_scope.has_focus) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    animate color { duration: co.theme.durations.fast;  }
    animate background { duration: co.theme.durations.fast; }
    animate border_color { duration: co.theme.durations.fast; }
}

// Default button with filled surface. Provides also an variant filled with the `co.theme.brushes.primary` brush, to get it set `primary` to `true`.
export Button := ButtonBase {
    // If set to  `true` the button will filled with co.theme.brushes.primary`
    property <bool> primary: false;

    background: primary ? co.theme.brushes.primary : co.theme.brushes.surface;
    color: primary ? co.theme.brushes.on_primary : co.theme.brushes.foreground;
    accessible-role: button;
    accessible-label <=> root.text;

    states [
        disabled when !enabled : {
            root.background: co.theme.brushes.surface_disabled;
            root.color: co.theme.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            root.background: primary ? co.theme.brushes.primary.darker(co.theme.state.pressed) : co.theme.brushes.surface.darker(co.theme.state.pressed);
            root.color:  primary ? co.theme.brushes.on_primary.darker(co.theme.state.pressed) : co.theme.brushes.foreground.darker(co.theme.state.pressed);
        }
        hover when root.has_hover : {
            root.background: primary ? co.theme.brushes.primary.darker(co.theme.state.hover) : co.theme.brushes.surface.darker(co.theme.state.hover);
            root.color:  primary ? co.theme.brushes.on_primary.darker(co.theme.state.hover) : co.theme.brushes.foreground.darker(co.theme.state.hover);
        }
    ]
}

export OutlineButton := ButtonBase {
    // If set to  `true` the button will filled with co.theme.brushes.primary`
    property <bool> primary: false;

    background: primary ? co.theme.brushes.primary : co.theme.brushes.background;
    border_width: 1px;
    color: primary ? co.theme.brushes.on_primary : co.theme.brushes.foreground;
    border_color: co.theme.brushes.border;
    accessible-role: button;
    accessible-label <=> root.text;

    states [
        disabled when !enabled : {
            root.background: co.theme.brushes.background;
            root.border_color: co.theme.brushes.border_disabled;
            root.color: co.theme.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            background: primary ? co.theme.brushes.primary.darker(co.theme.state.pressed) : co.theme.brushes.background.darker(co.theme.state.pressed);
            root.border_color: co.theme.brushes.border.darker(co.theme.state.pressed);
            root.color: primary ? co.theme.brushes.on_primary.darker(co.theme.state.pressed) : co.theme.brushes.foreground.darker(co.theme.state.pressed);
        }
        hover when root.has_hover : {
            background: primary ? co.theme.brushes.primary.darker(co.theme.state.hover) : co.theme.brushes.background.darker(co.theme.state.hover);
            root.border_color: co.theme.brushes.border.darker(co.theme.state.hover);
            root.color: primary ? co.theme.brushes.on_primary.darker(co.theme.state.hover) : co.theme.brushes.foreground.darker(co.theme.state.hover);
        }
    ]
}

// `RoundButtonBase` is used as base for buttons with a round shape.
export RoundButtonBase := TouchArea {
    // Used to set an optional icon on the button. Uses material icons check the `mi` global.
    property <string> icon: "";

    // Used to set the display text of the button.
    property <string> text: "";

    // Defines the color of the icon and text.
    property <brush> color;

    // Defines the border color.
    property <brush> border_color;

    // Defines the border width.
    property <length> border_width;

    // Defines the bacground color.
    property <brush> background;

    width: co.theme.sizes.medium;
    height: width;

    i_container := Rectangle {
        width: 100%;
        height: 100%;
        border_radius:(co.settings.minimize ? co.theme.sizes.small : co.theme.sizes.medium) / 2;
        background: root.background;
        border_width: root.border_width;
        border_color: root.border_color;

        if(root.icon != "") : MaterialIcon {
            x: (parent.width - width) / 2;
            y: (parent.height - height) / 2;
            icon_size: co.theme.icons.size_medium;
            icon_color: root.color;
            icon: root.icon;
        }

        if(root.text != "") : Text {
            color: root.color;
            x: (parent.width - width) / 2;
            y: (parent.height - height) / 2;
            font_size: co.theme.typo.label_medium.size;
            font_weight: co.theme.typo.label_medium.weight;
            font_family: co.theme.typo.label_medium.family;
            text: root.text;
        }
    }

    i_focus_scope := FocusScope {
        width: 0px; // Do not react on clicks
        enabled <=> root.enabled;
        key-pressed(event) => {
            if (event.text == " " || event.text == "\n") {
                root.clicked();
                return accept;
            }
            return reject;
        }
    }

    if(i_focus_scope.has_focus && !co.settings.minimize) : FocusBorder {
        width: root.width + 4px;
        height: root.height + 4px;
        x: (parent.width - width) / 2;
        y: (parent.height - height) / 2;
        border_radius: i_container.border_radius + 2px;
    }

    animate color { duration: co.theme.durations.fast;  }
    animate background { duration: co.theme.durations.fast; }
    animate border_color { duration: co.theme.durations.fast; }
}

// A round button.
export RoundButton := RoundButtonBase {
    background: co.theme.brushes.background;
    color: co.theme.brushes.foreground;
    accessible-role: button;

    states [
        disabled when !enabled : {
            root.color: co.theme.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            root.background: co.theme.brushes.background.darker(co.theme.state.pressed);
            root.color: co.theme.brushes.foreground.darker(co.theme.state.pressed);
        }
        hover when root.has_hover : {
            root.background: co.theme.brushes.background.darker(co.theme.state.hover);
            root.color: co.theme.brushes.foreground.darker(co.theme.state.hover);
        }
    ]
}

// A round outline button.
export RoundOutlineButton := RoundButtonBase {
    // If set to `true` the background will set to `co.theme.brushes.primary`.
    property <bool> primary: false;

    background: primary ? co.theme.brushes.primary : co.theme.brushes.background;
    border_width: 1px;
    color: primary ? co.theme.brushes.on_primary : co.theme.brushes.foreground;
    border_color: co.theme.brushes.border;
    accessible-role: button;

    states [
        disabled when !enabled : {
            root.background: co.theme.brushes.background;
            root.border_color: co.theme.brushes.border_disabled;
            root.color: co.theme.brushes.foreground_disabled;
        }
        pressed when root.pressed : {
            background: primary ? co.theme.brushes.primary.darker(co.theme.state.pressed) : co.theme.brushes.background.darker(co.theme.state.pressed);
            root.border_color: co.theme.brushes.border.darker(co.theme.state.pressed);
            root.color: primary ? co.theme.brushes.on_primary.darker(co.theme.state.pressed) : co.theme.brushes.foreground.darker(co.theme.state.pressed);
        }
        hover when root.has_hover : {
            background: primary ? co.theme.brushes.primary.darker(co.theme.state.hover) : co.theme.brushes.background.darker(co.theme.state.hover);
            root.border_color: co.theme.brushes.border.darker(co.theme.state.hover);
            root.color: primary ? co.theme.brushes.on_primary.darker(co.theme.state.hover) : co.theme.brushes.foreground.darker(co.theme.state.hover);
        }
    ]
}
